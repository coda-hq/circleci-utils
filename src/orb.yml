version: 2.1
description: "Utility orb for Coda Allows for: - Push alerts to opsgenie - Push Slack notifications - Cancel older CI alerts waiting for approval \n"
display:
    source_url: https://github.com/kr-project/circleci-utils
commands:
    cancel-older-awaiting-approvals:
        description: |
            Cancel all older pipelines waiting on manual approval.
            Depends on jq being present.
        parameters:
            CIRCLE_TOKEN:
                default: CIRCLE_TOKEN
                description: |
                    Env var of a token granted read access to the CircleCI api
                type: env_var_name
            vcs:
                default: gh
                description: |
                    Defaults to "gh", but allows other version control systems.
                type: string
        steps:
            - run:
                command: |-
                    #!/bin/bash
                    set -eo pipefail

                    BASE_URL="https://circleci.com/api/v2"
                    TOKEN="circle-token=${CIRCLECI_API_TOKEN}"
                    vcs="gh"
                    echo "${BASE_URL}/workflow/${CIRCLE_WORKFLOW_ID}"
                    echo "$TOKEN"
                    CURRENT_WORKFLOW=$(curl -s -H "Accept: application/json" "${BASE_URL}/workflow/${CIRCLE_WORKFLOW_ID}?${TOKEN}")
                    echo "$CURRENT_WORKFLOW"
                    CURRENT_WORKFLOW_TIMESTAMP=$(echo "$CURRENT_WORKFLOW" | jq -r ".created_at")
                    echo "Current workflow start time: ${CURRENT_WORKFLOW_TIMESTAMP}"

                    PROJECT_SLUG="project/${vcs}%2F${CIRCLE_PROJECT_USERNAME}%2F${CIRCLE_PROJECT_REPONAME}"
                    PIPELINE_IDS=$(curl -s -H "Accept: application/json" "${BASE_URL}/${PROJECT_SLUG}/pipeline?${TOKEN}" | jq -r ".items[].id")

                    for PIPELINE_ID in $PIPELINE_IDS; do
                        WORKFLOW=$(curl -s -H "Accept: application/json" "${BASE_URL}/pipeline/${PIPELINE_ID}/workflow?${TOKEN}" | jq ".items[0]")

                        WORKFLOW_ID=$(echo "$WORKFLOW" | jq -r ".id")
                        WORKFLOW_STATUS=$(echo "$WORKFLOW" | jq -r ".status")
                        WORKFLOW_CREATION_TIMESTAMP=$(echo "$WORKFLOW" | jq -r ".created_at")

                        echo "Workflow data: ${WORKFLOW_ID}, ${WORKFLOW_STATUS}, ${WORKFLOW_CREATION_TIMESTAMP}"

                        if [[ $WORKFLOW_CREATION_TIMESTAMP < $CURRENT_WORKFLOW_TIMESTAMP && "$WORKFLOW_STATUS" == "on_hold" ]]; then
                        echo "Canceling older workflow waiting for manual approval: ${WORKFLOW_ID}"
                        curl -s -X POST -H "Accept: application/json" "${BASE_URL}/workflow/${WORKFLOW_ID}/cancel?${TOKEN}"
                        fi
                    done
                environment:
                    vcs: <<parameters.vcs>>
                name: Cancel older pipelines waiting on manual approval.
    notify:
        description: Send build results to Opsgenie API, with detailed information
        parameters:
            CIRCLE_TOKEN:
                default: CIRCLE_TOKEN
                description: |
                    Env var of a token granted read access to the CircleCI api
                type: env_var_name
            CODA_API_TOKEN:
                default: STAGING_CODA_TOKEN
                description: |
                    Env var of a token granted read access to the CODA_USER_ROSTER_TABLE_URL document.
                type: env_var_name
            endpoint:
                default: OPSGENIE_WEBHOOK
                description: Enter either your Full URL value that you copied in Opsgenie Integration Page
                type: env_var_name
            on_failure:
                default: false
                description: Failure information of circleci build
                type: boolean
            on_success:
                default: true
                description: Success information of circleci build
                type: boolean
        steps:
            - run:
                command: "#!/bin/bash\nset -eo pipefail\nCODA_CIRCLECI_USER_NAME_COL=\"c-6ni4kHGNwE\"\nCODA_CIRCLECI_USER_ALIAS_COL=\"c-26If9Zttyp\"\nUSER_EMAIL=\"\"\nCIRCLE_USERNAME=$CIRCLE_USERNAME\nfunction run_main() {\n    USER_ALIAS=$(curl -s -H \"Authorization: Bearer ${CODA_API_TOKEN}\" \\\n    -G --data-urlencode \"query=${CODA_CIRCLECI_USER_NAME_COL}:\\\"${CIRCLE_USERNAME}\\\"\" \\\n    'https://staging.coda.io/apis/v1/docs/s2i6oFeghW/tables/grid-QGyaiXZDwu/rows' \\\n    | jq --arg CODA_CIRCLECI_USER_ALIAS_COL \"$CODA_CIRCLECI_USER_ALIAS_COL\" '.items[0].values.\"'$CODA_CIRCLECI_USER_ALIAS_COL'\"' | tr -d '\"')\n    if [ \"$USER_ALIAS\" != \"null\" ]; then\n        USER_EMAIL=$([[ \"${USER_ALIAS}\" == *@* ]] && echo \"$USER_ALIAS\" || echo \"${USER_ALIAS}@coda.io\")\n        echo \"$USER_EMAIL\"\n        echo \"export USER_EMAIL=${USER_EMAIL}\" >> \"$BASH_ENV\"\n        \n    fi\n    \n    if [ -n \"$PUSH_REMINDER_BOT_TOKEN\" ]; then \n        echo \"$USER_EMAIL\"\n        SLACK_USER_ID=$(curl -s -H \"Authorization: Bearer $PUSH_REMINDER_BOT_TOKEN\" \\\n            \"https://slack.com/api/users.lookupByEmail?email=${USER_EMAIL}\" \\\n            | jq '.user.id' | tr -d '\"')\n        echo \"$SLACK_USER_ID\"\n        echo \"export SLACK_USER_ID=${SLACK_USER_ID}\" >> \"$BASH_ENV\"\n    fi\n}\n\nORB_TEST_ENV=\"bats-core\"\nif [ \"${0#*$ORB_TEST_ENV}\" == \"$0\" ]; then\n    run_main\nfi"
                environment:
                    CODA_API_TOKEN: << parameters.CODA_API_TOKEN >>
                name: Fetch User Information
                when: always
            - run:
                command: "#!/bin/bash\nCIRCLE_FETCH_PAGE_SIZE=100\nCIRCLE_FETCH_MAX_PAGES=100\nresponse=\"\"\nfunction get_recent_builds() {\n    offset=$(($1*CIRCLE_FETCH_PAGE_SIZE))\n    url=\"https://circleci.com/api/v1/project/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/tree/${CIRCLE_BRANCH}?circle-token=${CIRCLE_TOKEN}&limit=100&offset=${offset}&filter=successful\"\n    http_response=$(curl --write-out '%{http_code}' --silent --output /dev/null \"$url\")\n    if [[ $http_response != \"200\" ]]; then\n        echo \"Error: CircleCI page not found\"\n        exit 0\n    fi\n    response=$(curl \"$url\" | jq '.')\n\n}\n\nfunction run_main() {\n    latest_build_num=0\n    latest_git_hash=\"\"\n    job_name=$CIRCLE_JOB\n    page=0\n    DIFF_URL=\"\"\n    while [[ $latest_git_hash == \"\" ]] && [[ $page < $CIRCLE_FETCH_MAX_PAGES ]]\n    do\n        # https://unix.stackexchange.com/questions/184863/what-is-the-meaning-of-ifs-n-in-bash-scripting\n        IFS=$'\\n'\n        get_recent_builds $page\n        for build in $(echo \"$response\" | jq -c '.[]')\n        do\n            if [[ $(echo \"$build\" | jq -r '.outcome') != \"success\" ]]; then\n                continue\n            fi\n            # To Do: Change to jq instead of grep?\n            if [[ $(echo \"$build\" | grep 'workflows') == \"\" ]]; then \n                continue \n            fi \n            if (( $(echo \"$build\" | jq  -r '.build_num') > latest_build_num )) && [[ $(echo \"$build\" | jq -r '.workflows.job_name') == \"$job_name\" ]]; then\n                latest_build_num=$(echo \"$build\" | jq -r '.build_num') \n                latest_git_hash=$(echo \"$build\" | jq -r '.vcs_revision')\n            fi\n        done\n        if [ -z \"$latest_git_hash\" ]; then\n            page=$((page+1))\n        fi\n\n    done\n    if [ -n \"$latest_git_hash\" ]; then\n        DIFF_URL=\"https://github.com/kr-project/${CIRCLE_PROJECT_REPONAME}/compare/${latest_git_hash}...${CIRCLE_SHA1}\"\n        echo \"$DIFF_URL\"\n        echo \"export DIFF_URL=$DIFF_URL\" >> \"$BASH_ENV\"\n    fi\n}\n\n# Will not run if sourced for bats-core tests.\n# View src/tests for more information.\nORB_TEST_ENV=\"bats-core\"\nif [ \"${0#*$ORB_TEST_ENV}\" == \"$0\" ]; then\n    run_main\nfi\n"
                environment:
                    CIRCLE_TOKEN: << parameters.CIRCLE_TOKEN >>
                name: Get diff url
                when: on_fail
            - run:
                command: |
                    echo '{}' | jq '{
                      "message": "[CircleCI] [#\(env.CIRCLE_PREVIOUS_BUILD_NUM)]: workflow \(env.CIRCLE_BRANCH) stage \(env.CIRCLE_STAGE) job \(env.CIRCLE_JOB)",
                      "alias": "\(env.CIRCLE_PROJECT_REPONAME)/\(env.CIRCLE_BRANCH)#\(env.CIRCLE_JOB) ",
                      "description":"See \(env.CIRCLE_BUILD_URL) for more details. ",
                      "outcome": "unknown",
                      "username": env.CIRCLE_USERNAME,
                      "details": {
                        "build_number":env.CIRCLE_PREVIOUS_BUILD_NUM,
                        "build_url": env.CIRCLE_BUILD_URL
                        },
                      "tags": ["TestingAlerts"],
                    }' > /tmp/raw-webhook.json
                name: Bundle build info into webhook payload
                when: always
            - when:
                condition: $USER_EMAIL
                steps:
                    - run:
                        command: |
                            cat /tmp/raw-webhook.json | jq --arg USER_EMAIL $USER_EMAIL '.responders +=  [{"username":$USER_EMAIL, "type":"user"}]' > /tmp/webhook2.json
                            cp /tmp/webhook2.json /tmp/raw-webhook.json
                        name: Add user email to Webhook
            - when:
                condition: $DIFF_URL
                steps:
                    - run:
                        command: |
                            cat /tmp/raw-webhook.json | jq --arg DIFF_URL $DIFF_URL '.description +=  " Compare with last passing commit: '$DIFF_URL'"' > /tmp/raw-webhook2.json
                            cp /tmp/raw-webhook2.json /tmp/raw-webhook.json
                        name: Add latest git hash to Webhook
            - when:
                condition: <<parameters.on_success>>
                steps:
                    - run:
                        command: |
                            cat /tmp/raw-webhook.json | jq '.payload.outcome="success"' > /tmp/webhook.json
                            curl -X POST -H"Content-Type:application/json" -H "Authorization: GenieKey ${OPS_GENIE_API_KEY}" -d @/tmp/webhook.json https://api.opsgenie.com/v2/alerts
                        name: Notify $<<parameters.endpoint>> with Success Webhook
                        when: on_success
            - when:
                condition: <<parameters.on_failure>>
                steps:
                    - run:
                        command: |
                            cat /tmp/raw-webhook.json | jq '.payload.outcome="failed"'  > /tmp/webhook.json
                            curl -X POST -H"Content-Type:application/json" -H "Authorization: GenieKey ${OPS_GENIE_API_KEY}" -d @/tmp/webhook.json https://api.opsgenie.com/v2/alerts
                        name: Notify $<<parameters.endpoint>> with Failure Webhook
                        when: on_fail
    slack-notify-waiting-for-approval:
        description: |
            Notifies the current workflow owner that their workflow is pending approval to proceed.
            Depends on jq being present.

            Setup:
              1. Create Coda document with a table containing columns `circleci alias` (ex: github username) and `email`, and populate this table with information for each github user.
              3. Find the docId, tableId, and columnIds for the circleci user alias and email columnIds.
              4. Create a Coda API token for this document at https://coda.io/account - limit the token to read access to the target table.
              5. Setup a Slack Bot account with scopes `users:read`, `users:read.email`, and `chat:write`.
              6. Configure orb based on required args
        parameters:
            CODA_API_TOKEN:
                default: $STAGING_CODA_TOKEN
                description: |
                    Env var of a token granted read access to the CODA_USER_ROSTER_TABLE_URL document.
                type: string
            CODA_CIRCLECI_USER_ALIAS_COL:
                default: c-26If9Zttyp
                description: |
                    Coda columnId of the column storing the user alias (when using EMAIL_DOMAIN), or fully qualified email.
                type: string
            CODA_CIRCLECI_USER_NAME_COL:
                default: c-6ni4kHGNwE
                description: |
                    Coda columnId of the column storing the CircleCI username.
                type: string
            CODA_USER_ROSTER_TABLE_URL:
                default: https://staging.coda.io/apis/v1/docs/s2i6oFeghW/tables/grid-QGyaiXZDwu/rows
                description: |
                    Fully qualified API URL to a table containing CIRCLECI_USERNAMEs to email aliases.    Must be of the form
                    https://coda.io/apis/v1/docs/<DOCID>/tables/<TABLEID>/rows.
                type: string
            EMAIL_DOMAIN:
                default: coda.io
                description: |
                    Optional email domain for users within the workspace.   Must be specified if user aliases are not fully qualified.
                type: string
            SLACK_BOT_TOKEN:
                description: |
                    Token used by Slack bot application.   Must have scopes `users:read`, `users:read.email`, and `chat:write`.
                type: string
            vcs:
                default: gh
                description: |
                    Defaults to "gh", but allows other version control systems.
                type: string
        steps:
            - run:
                command: "#!/bin/bash\nset -eo pipefail\nCODA_CIRCLECI_USER_NAME_COL=\"c-6ni4kHGNwE\"\nCODA_CIRCLECI_USER_ALIAS_COL=\"c-26If9Zttyp\"\nUSER_EMAIL=\"\"\nCIRCLE_USERNAME=$CIRCLE_USERNAME\nfunction run_main() {\n    USER_ALIAS=$(curl -s -H \"Authorization: Bearer ${CODA_API_TOKEN}\" \\\n    -G --data-urlencode \"query=${CODA_CIRCLECI_USER_NAME_COL}:\\\"${CIRCLE_USERNAME}\\\"\" \\\n    'https://staging.coda.io/apis/v1/docs/s2i6oFeghW/tables/grid-QGyaiXZDwu/rows' \\\n    | jq --arg CODA_CIRCLECI_USER_ALIAS_COL \"$CODA_CIRCLECI_USER_ALIAS_COL\" '.items[0].values.\"'$CODA_CIRCLECI_USER_ALIAS_COL'\"' | tr -d '\"')\n    if [ \"$USER_ALIAS\" != \"null\" ]; then\n        USER_EMAIL=$([[ \"${USER_ALIAS}\" == *@* ]] && echo \"$USER_ALIAS\" || echo \"${USER_ALIAS}@coda.io\")\n        echo \"$USER_EMAIL\"\n        echo \"export USER_EMAIL=${USER_EMAIL}\" >> \"$BASH_ENV\"\n        \n    fi\n    \n    if [ -n \"$PUSH_REMINDER_BOT_TOKEN\" ]; then \n        echo \"$USER_EMAIL\"\n        SLACK_USER_ID=$(curl -s -H \"Authorization: Bearer $PUSH_REMINDER_BOT_TOKEN\" \\\n            \"https://slack.com/api/users.lookupByEmail?email=${USER_EMAIL}\" \\\n            | jq '.user.id' | tr -d '\"')\n        echo \"$SLACK_USER_ID\"\n        echo \"export SLACK_USER_ID=${SLACK_USER_ID}\" >> \"$BASH_ENV\"\n    fi\n}\n\nORB_TEST_ENV=\"bats-core\"\nif [ \"${0#*$ORB_TEST_ENV}\" == \"$0\" ]; then\n    run_main\nfi"
                name: Fetch User Information from Look Up Table
            - when:
                condition: $SLACK_USER_ID
                steps:
                    - run:
                        command: |-
                            set -eo pipefail
                            curl -X POST -H "Authorization: Bearer $PUSH_REMINDER_BOT_TOKEN" \
                              -H "Content-Type: application/json" -d \
                              "{ \
                                \"channel\": \"${SLACK_USER_ID}\", \
                                \"attachments\": [ \
                                  { \
                                    \"text\": \"Pending Approval for ${CIRCLE_PROJECT_REPONAME} push (${CIRCLE_USERNAME})\", \
                                    \"fields\": [ \
                                      { \
                                        \"title\": \"Project\", \
                                        \"value\": \"${CIRCLE_PROJECT_REPONAME}\", \
                                        \"short\": true \
                                      }, \
                                      { \
                                        \"title\": \"Job Number\", \
                                        \"value\": \"${CIRCLE_BUILD_NUM}\", \
                                        \"short\": true \
                                      } \
                                    ], \
                                    \"actions\": [ \
                                      { \
                                        \"type\": \"button\", \
                                        \"text\": \"Visit Workflow\", \
                                        \"url\": \"https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}\" \
                                      } \
                                    ], \
                                    \"color\": \"#f46a54\" \
                                  } \
                                ] \
                              }" \
                              'https://slack.com/api/chat.postMessage'
                        name: Send Slack Message
executors:
    default:
        description: |
            Default executor
        docker:
            - image: circleci/buildpack-deps:buster-curl
        resource_class: small
jobs:
    cancel-older-awaiting-approvals:
        description: |
            Cancel all older pipelines waiting on manual approval.
            Depends on jq being present.
        executor: default
        parameters:
            CIRCLE_TOKEN:
                default: CIRCLE_TOKEN
                description: |
                    Env var of a token granted read access to the CircleCI api
                type: env_var_name
            vcs:
                default: gh
                description: |
                    Defaults to "gh", but allows other version control systems.
                type: string
        steps:
            - cancel-older-awaiting-approvals:
                CIRCLE_TOKEN: << parameters.CIRCLE_TOKEN >>
                vcs: << parameters.vcs >>
    slack-notify-waiting-for-approval:
        description: |
            Notifies the current workflow owner that their workflow is pending approval to proceed.
            Depends on jq being present.

            Setup:
              1. Create Coda document with a table containing columns `circleci alias` (ex: github username) and `email`, and populate this table with information for each github user.
              3. Find the docId, tableId, and columnIds for the circleci user alias and email columnIds.
              4. Create a Coda API token for this document at https://coda.io/account - limit the token to read access to the target table.
              5. Setup a Slack Bot account with scopes `users:read`, `users:read.email`, and `chat:write`.
              6. Configure orb based on required args
        executor: default
        parameters:
            CODA_API_TOKEN:
                default: $STAGING_CODA_TOKEN
                description: |
                    Env var of a token granted read access to the CODA_USER_ROSTER_TABLE_URL document.
                type: string
            CODA_CIRCLECI_USER_ALIAS_COL:
                default: c-26If9Zttyp
                description: |
                    Coda columnId of the column storing the user alias (if using EMAIL_DOMAIN), or fully qualified email.
                type: string
            CODA_CIRCLECI_USER_NAME_COL:
                default: c-6ni4kHGNwE
                description: |
                    Coda columnId of the column storing the CircelCI username (typically github alias).
                type: string
            CODA_USER_ROSTER_TABLE_URL:
                default: https://staging.coda.io/apis/v1/docs/s2i6oFeghW/tables/grid-QGyaiXZDwu/rows
                description: |
                    Fully qualified API URL to a table containing CIRCLECI_USERNAME to email aliases.    Must be of the form
                    https://coda.io/apis/v1/docs/<DOCID>/tables/<TABLEID>/rows.
                type: string
            EMAIL_DOMAIN:
                default: coda.io
                description: |
                    Optional email domain for users within the workspace.   Must be specified if user aliases are not fully qualified.
                type: string
            SLACK_BOT_TOKEN:
                description: |
                    Token used by Slack bot application.   Must have scopes `users:read`, `users:read.email`, and `chat:write`.
                type: string
            vcs:
                default: gh
                description: |
                    Defaults to "gh", but allows other version control systems.
                type: string
        steps:
            - slack-notify-waiting-for-approval:
                CODA_API_TOKEN: << parameters.CODA_API_TOKEN >>
                CODA_CIRCLECI_USER_ALIAS_COL: << parameters.CODA_CIRCLECI_USER_ALIAS_COL >>
                CODA_CIRCLECI_USER_NAME_COL: << parameters.CODA_CIRCLECI_USER_NAME_COL >>
                CODA_USER_ROSTER_TABLE_URL: << parameters.CODA_USER_ROSTER_TABLE_URL >>
                EMAIL_DOMAIN: << parameters.EMAIL_DOMAIN >>
                SLACK_BOT_TOKEN: << parameters.SLACK_BOT_TOKEN >>
                vcs: << parameters.vcs >>
examples:
    example:
        description: "Three differeent use cases \n"
        usage:
            version: "2.1"
            orbs:
                utils: coda/utils@<version>
            workflows:
                use-my-orb:
                    jobs:
                        - my-job
                        - utils/cancel-older-awaiting-approvals:
                            token: ${CIRCLECI_API_TOKEN}
                        - utils/slack-notify-waiting-for-approval:
                            CODA_API_TOKEN: ${GITHUB_TO_SLACK_CODA_API_TOKEN}
                            SLACK_BOT_TOKEN: ${PUSH_REMINDER_BOT_TOKEN}

